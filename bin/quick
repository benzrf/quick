#!/usr/bin/env ruby
require 'thor'
require 'brb'
require 'uri'
require 'fileutils'
require 'git'
require_relative '../lib/quick'

class QuickCLI < Thor
	map '-v' => :version
	desc 'version', "print your version of Quick"
	def version
		puts Quick::VERSION
	end

	desc 'start MOUNT_DIR', "run Quick, mounting the FS on MOUNT_DIR"
	option :foreground, type: :boolean, aliases: :f
	option :no_checkpoint, type: :boolean, aliases: :n
	def start(dir)
		silent = '> /dev/null 2> /dev/null'
		using_dmtcp = !options.no_checkpoint? and
			system "which git #{silent}" and
			system "dmtcp_launch #{silent}"
		if using_dmtcp
			git_dir = File.join(Dir.home, '.quick', File.basename(dir))
			FileUtils.mkdir_p git_dir
			begin
				Git.open git_dir
			rescue ArgumentError
				Git.init git_dir
			end
			exec 'dmtcp_launch', '-c', git_dir, '--new-coordinator', $0, *ARGV, '-n'
		end
		if File.file? dir or
			(File.directory? dir and Dir.entries(dir).size > 2)
			puts "cannot mount on #{dir}"
			exit 1
		elsif not File.directory? dir
			existed = false
			Dir.mkdir dir
		else
			existed = true
		end
		unless options.foreground?
			if (pid = fork)
				Process.detach pid
				exit
			end
		end
		Quick.run dir
		Dir.rmdir dir unless existed
	end

	desc 'stop', "stop your current Quick instance"
	def stop
		Quick.stop
	end

	desc 'pry', "start a pry in an instance of the current module"
	option :module, type: :boolean, aliases: :m
	def pry
		uri = Quick.pry_here !options.module?
		system "pry-remote-em", uri
	end

	desc 'module NAME', "create a new module here"
	def module(name)
		Quick.module_here name
	end

	map 'class' => :class_
	desc 'class NAME [SUPERCLASS_PATH]', "create a new class here"
	def class_(name, super_path='Object')
		Quick.class_here name, super_path
	end

	desc 'eval CODE', "evaluate some code in an instance of the current module"
	option :module, type: :boolean, aliases: :m
	def eval(code)
		result = Quick.eval_here code, !options.module?
		puts "=> #{result}"
	end

	desc 'checkpoint MESSAGE', "take a snapshot of this Quick instance and commit it to the repository"
	def checkpoint(msg)
		Quick.checkpoint msg
	end

	desc 'git COMMAND', "run a command on the repository for this Quick instance"
	def git(*args)
		repo = Git.open Quick.repo
		old_head = repo.log.first
		system 'git', args
		Quick.load unless repo.log.first == old_head
	end
end

begin
	QuickCLI.start
rescue RuntimeError => e
	puts e.message
	exit 1
end

# vim:tabstop=2 shiftwidth=2 noexpandtab:

